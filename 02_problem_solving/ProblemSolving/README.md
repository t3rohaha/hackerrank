# Problem Solving

## Content

01. [Warmup](#warmup)
02. [Implementation](#implementation)
03. [Strings](#strings)
04. [Sorting](#sorting)
05. [Search](#search)
06. [Graph Theory](#graph-theory)
07. [Greedy](#greedy)
08. [Dynamic Programming](#dynamic-programming)
09. [Constructive Algorithms](#constructive-algorithms)
10. [Bit Manipulation](#bit-manipulation)
11. [Recursion](#recursion)
12. [Game Theory](#game-theory)
13. [NP Complete](#np-complete)
14. [Debugging](#debugging)

## Warmup

Warmup problems are generally simple and designed to get you started with
problem-solving. They usually involve basic programming concepts and can often
be solved with straightforward algorithms. Examples include basic arithmetic,
loops, and conditional statements.

## Implementation

Implementation problems require you to translate a given description or
algorithm into code. These problems test your ability to follow instructions and
implement logic correctly. They may not involve complex algorithms but often
require careful reading and attention to detail.

## Strings

Strings problems involve operations on strings, such as searching, matching,
manipulation, and transformation. These can include tasks like finding
substrings, checking for palindromes, and using string-related functions and
methods.

## Sorting

Sorting problems involve arranging data in a particular order. Common algorithms
include QuickSort, MergeSort, BubbleSort, and others. These problems test your
understanding of different sorting techniques and their efficiencies.

## Search

Search problems involve finding specific elements or patterns within data
structures. This includes linear search, binary search, and more complex search
algorithms used in graphs and trees.

## Graph Theory

Graph Theory problems involve nodes and edges, and require understanding of
concepts such as connectivity, traversal (BFS, DFS), shortest paths (Dijkstraâ€™s,
Bellman-Ford), and more. These problems test your ability to model real-world
situations as graphs and solve related problems.

## Greedy

Greedy problems involve making the most optimal choice at each step to find a
global optimum. These problems test your ability to determine the local optimal
solutions that lead to the best overall outcome, such as in interval scheduling,
Huffman coding, and minimum spanning trees.

## Dynamic Programming

Dynamic Programming (DP) problems involve breaking down problems into simpler
subproblems and storing the results of these subproblems to avoid redundant
calculations. These problems test your ability to identify overlapping
subproblems and optimal substructure properties, such as in the knapsack
problem, Fibonacci sequence, and longest common subsequence.

## Constructive Programming

Constructive Algorithms involve constructing a solution incrementally. These
problems require you to build a solution from scratch in a step-by-step manner,
often involving creative approaches to ensure all constraints are met.

## Bit Manipulation

Bit Manipulation problems involve operations on binary representations of
numbers. These problems test your understanding of bitwise operators (AND, OR,
XOR, NOT, shifts) and their applications, such as in finding unique elements,
bitwise addition, and optimization problems.

## Recursion

Recursion problems involve solving a problem by breaking it down into smaller
instances of the same problem. These problems test your ability to design
recursive solutions and understand the base case and recursive case, such as in
solving Tower of Hanoi, factorial calculation, and tree traversals.

## Game Theory

Game Theory problems involve strategic interactions between players making
decisions. These problems test your ability to determine optimal strategies,
predict outcomes, and understand concepts like Nash equilibrium, minimax
algorithm, and zero-sum games.

## NP Complete

NP Complete problems are a class of problems for which no efficient solution
algorithm is known. These problems test your ability to approximate solutions,
understand computational complexity, and reduce problems to known NP-complete
problems, such as in the traveling salesman problem and the knapsack problem.

## Debugging

Debugging problems involve identifying and fixing bugs in given code. These
problems test your ability to read and understand existing code, spot errors,
and correct them to produce the desired output.